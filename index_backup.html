<!DOCTYPE html>
<html>
  <head>
    <title>Gu√≠a Virtual - La Floresta</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Librer√≠as externas -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Font Awesome para iconos bonitos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <!-- Estilos locales -->
    <link rel="stylesheet" href="./css/styles.css" />
  </head>
  <body>
    <div id="map"></div>
    
    <!-- Panel de instrucciones para testing -->
    <div id="testing-panel">
      <h3>üéÆ Modo Testing</h3>
      <div class="testing-instructions">
        <strong>Presiona 'T'</strong> para activar testing
      </div>
      <div class="testing-instructions">
        Luego usa las flechas:<br>
        ‚¨ÜÔ∏è ‚¨áÔ∏è ‚¨ÖÔ∏è ‚û°Ô∏è (‚âà5m cada clic)
      </div>
      <div class="testing-instructions">
        <small>üîä Audio: üë® Hombre (descripci√≥n) + üë© Mujer (navegaci√≥n)</small>
      </div>
      <div class="testing-instructions">
        <small>üéØ Visual: üü† Siguiente punto + üîó Ruta azul</small>
      </div>
      <div id="testing-status" class="testing-status" style="display: none;">
        ‚úÖ Modo Testing Activo
      </div>
    </div>

    <script>
      // --- FASE 1: TUS DATOS (PUNTOS DE INTER√âS) ---
      // Aqu√≠ es donde pones tus coordenadas y rese√±as.
      // He usado el formato GeoJSON que te recomend√©.
      const misPuntos = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.677874536889675, -34.76094347598904],
            },
            properties: {
              id: "poi_1",
              nombre: "Hotel La Floresta",
              descripcion:
                "El ic√≥nico Ex-Hotel La Floresta es el s√≠mbolo del balneario...",
              audio: "audio/hotel.mp3",
              orden: 1,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.67833471832813, -34.75902725049957], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_2",
              nombre: "Sin Nombre",
              descripcion:
                "Hay que averiguar el nombre y descripci√≥n de este punto...",
              audio: "audio/country.mp3",
              orden: 10,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.67574992051011, -34.75374934645494], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_3",
              nombre: "Plaza 33",
              descripcion:
                "La Plaza 33 es un espacio p√∫blico que fomenta la convivencia y el esparcimiento.",
              audio: "audio/plaza33.mp3",
              orden: 7,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.668644494635636, -34.75719219349257], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_4",
              nombre: "Plaza Salvador Garc√≠a Pintos",
              descripcion:
                " Inaugurada en 2021, esta plaza es un ejemplo de transformaci√≥n. Lo que antiguamente era un basural, hoy es un espacio p√∫blico renovado y lleno de vida. ",
              audio: "audio/plazaSalvador.mp3",
              orden: 6,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.667910491734084, -34.75958472020964], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_5",
              nombre: "Plazoleta del Leonismo",
              descripcion:
                "Esta plazoleta es un homenaje a los valores del Club de Leones (Leonismo) y su servicio ...",
              audio: "audio/plazaleonismo.mp3",
              orden: 5,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.673522605168316, -34.7595672510129], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_6",
              nombre: "Plaza Artigas",
              descripcion:
                "Como en la mayor√≠a de las localidades uruguayas, esta plaza rinde homenaje al Pr√≥cer de la P√°tria ...",
              audio: "audio/plazaartigas.mp3",
              orden: 4,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.67520041687363, -34.75938912256196], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_7",
              nombre: "Plaza Don Orione",
              descripcion:
                "Esta plaza toma su nombre en honor a San Luis Orione, fundador del Movimiento Orionita...",
              audio: "audio/plazaorione.mp3",
              orden: 11,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.67574879662696, -34.76037254637836], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_8",
              nombre: "Plaza Zorrilla de San Mart√≠n",
              descripcion:
                "Dedicada al 'Poeta de la Patria', Juan Zorrilla de San Mart√≠n. Este espacio rinde tributo a su monumental obra literaria",
              audio: "audio/plazazorrilla.mp3",
              orden: 3,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.67690120312782, -34.76062577419499], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_9",
              nombre: "Plaza Liga de Fomento",
              descripcion:
                "Este espacio celebra el esp√≠ritu c√≠vico de la Liga de Fomento de La Floresta.",
              audio: "audio/plazaligafomento.mp3",
              orden: 2,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.680042668032684, -34.75882526846987], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_10",
              nombre: "Plaza Lavalleja",
              descripcion:
                "Esta plaza honra la memoria de Juan Antonio Lavalleja, l√≠der de los Treinta y Tres Orientales. Es un espacio que ...",
              audio: "audio/plazalavalleja.mp3",
              orden: 9,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.68000110452356, -34.752043461814516], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_11",
              nombre: "Plaza Zabala",
              descripcion:
                "Un rinc√≥n que recuerda al fundador de Montevideo, Bruno Mauricio de Zabala. Esta plaza conecta al ...",
              audio: "audio/plazazabala.mp3",
              orden: 8,
            },
          },
          {
            type: "Feature",
            geometry: {
              type: "Point",
              // ¬°IMPORTANTE! Reemplaza esto con tus coordenadas
              coordinates: [-55.676521832650906, -34.75779537345324], // [Longitud, Latitud]
            },
            properties: {
              id: "poi_12",
              nombre: "Plaza Rivera",
              descripcion:
                "Dedicada a Fructuoso Rivera, primer presidente constitucional de Uruguay y figura clave en los primeros a√±os de la Rep√∫blica.",
              audio: "audio/plazarivera.mp3",
              orden: 12,
            },
          },

          // ... Agrega aqu√≠ tus otros 10 puntos ...
        ],
      };

      // --- RUTAS POR CALLES ENTRE PUNTOS ---
      // Define las rutas que siguen las calles entre cada par de puntos consecutivos
      const rutasCalles = {
        // Formato: "puntoOrigen_puntoDestino": [array de coordenadas siguiendo calles]
        // Coordenadas en formato [longitud, latitud]
        
        // Ruta 1 a 2
        "1_2": [
          [-55.67774224315738, -34.76043563352309],
          [-55.677309327927105, -34.7604460328947],
          [-55.677028312777615, -34.76047099138123],
          [-55.67702071777357, -34.76061658240229]
        ],
        
        // Ruta 2 a 3
        "2_3": [
          [-55.67704317308188, -34.760602062986486],
          [-55.67702752030683, -34.76047489767304],
          [-55.67653386907653, -34.760537128779745],
          [-55.67598133404287, -34.76079494344367],
          [-55.67577311851101, -34.760452828145866]
        ],
        
        // Ruta 3 a 4
        "3_4": [
          [-55.675754969690566, -34.760393279766184],
          [-55.67570762542184, -34.76032176242638],
          [-55.6750202090306, -34.76034170025042],
          [-55.674542775828755, -34.760219402976986],
          [-55.67367642231132, -34.75984039046047]
        ],
        
        // Ruta 4 a 5
        "4_5": [
          [-55.67320755622514, -34.75924913289344],
          [-55.67288790531391, -34.75898055326243],
          [-55.67236484018643, -34.758950711027275],
          [-55.668485440491054, -34.760126486932734],
          [-55.668194848763136, -34.760132455300244],
          [-55.66783160909128, -34.75991162558568],
          [-55.66770084280942, -34.75978032115108],
          [-55.66782434429784, -34.75952368006228]
        ],
        
        // Ruta 5 a 6
        "5_6": [
          [-55.66783160908671, -34.75945205913525],
          [-55.66847091090917, -34.75744067983614]
        ],
        
        // Ruta 6 a 7
        "6_7": [
          [-55.66892295191356, -34.75697004537532],
          [-55.672793409173146, -34.75521501052166],
          [-55.67336446024424, -34.75564074022483],
          [-55.67539830329828, -34.754009590653645]
        ],
        
        // Ruta 7 a 8
        "7_8": [
          [-55.67581434179134, -34.75339602369638],
          [-55.676152742426055, -34.75357848357132],
          [-55.67976939920962, -34.752049283579154]
        ],
        
        // Ruta 8 a 9
        "8_9": [
          [-55.6802347000455, -34.75205797231916],
          [-55.68283615491267, -34.75279650987077],
          [-55.680403900346306, -34.758530811997524]
        ],
        
        // Ruta 9 a 10
        "9_10": [
          [-55.67956054171363, -34.75886702172613],
          [-55.67831784629535, -34.75900642805567]
        ],
        
        // Ruta 10 a 11
        "10_11": [
          [-55.67806506224961, -34.75904332903884],
          [-55.67545490279676, -34.759416444654846]
        ],
        
        // Ruta 11 a 12
        "11_12": [
          [-55.67536248648765, -34.75929757149675],
          [-55.67655031767404, -34.7577847287694]
        ]
      };

      // --- FASE 2: EL MAPA (LEAFLET) ---

      // 1. Inicializar el mapa
      // Centramos el mapa en La Floresta (ajusta estas coordenadas si es necesario)
      const map = L.map("map").setView([-34.757, -55.665], 16);

      // 2. Cargar el mapa base (OpenStreetMap)
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "¬© OpenStreetMap",
      }).addTo(map);

      // Funci√≥n para determinar el icono basado en el nombre del punto
      function obtenerIconoPorNombre(nombre) {
        const nombreLower = nombre.toLowerCase();

        if (nombreLower.startsWith("pla")) {
          return {
            className: "icon-plaza",
            iconClass: "fas fa-tree", // Icono de √°rbol para plazas
            title: "Plaza",
          };
        } else if (
          nombreLower.startsWith("clu") ||
          nombreLower.includes("club") ||
          nombreLower.includes("country")
        ) {
          return {
            className: "icon-club",
            iconClass: "fas fa-users", // Icono de personas para clubes
            title: "Club/Instituci√≥n Recreativa",
          };
        } else if (nombreLower.includes("hotel")) {
          return {
            className: "icon-hotel",
            iconClass: "fas fa-bed", // Icono de cama para hoteles
            title: "Hotel",
          };
        } else {
          return {
            className: "icon-default",
            iconClass: "fas fa-map-marker-alt", // Icono gen√©rico
            title: "Punto de Inter√©s",
          };
        }
      }

      // Funci√≥n para crear icono personalizado
      function crearIconoPersonalizado(nombre) {
        const tipoIcon = obtenerIconoPorNombre(nombre);

        return L.divIcon({
          className: "custom-div-icon",
          html: `<div class="poi-icon ${tipoIcon.className}" title="${tipoIcon.title}">
                   <i class="${tipoIcon.iconClass}"></i>
                 </div>`,
          iconSize: [30, 30],
          iconAnchor: [15, 15],
          popupAnchor: [0, -15],
        });
      }

      // Un objeto para guardar nuestros marcadores y poder llamarlos
      let marcadoresLeaflet = {};
      
      // Variables para gesti√≥n visual de navegaci√≥n
      let rutaActual = null; // L√≠nea azul hacia el siguiente punto
      let puntoSiguienteActual = null; // Referencia al pr√≥ximo punto destacado

      // 3. Agregar tus puntos (POIs) al mapa
      L.geoJSON(misPuntos, {
        pointToLayer: function (feature, latlng) {
          // Crear marcador con icono personalizado basado en el nombre
          const iconoPersonalizado = crearIconoPersonalizado(
            feature.properties.nombre
          );
          return L.marker(latlng, { icon: iconoPersonalizado });
        },
        onEachFeature: function (feature, layer) {
          // Esto crea el popup usando la informaci√≥n de tus datos
          const popupContent = `<b>${feature.properties.nombre}</b><br>${feature.properties.descripcion}`;
          layer.bindPopup(popupContent);
          // Guardamos el marcador (layer) usando su ID como llave
          marcadoresLeaflet[feature.properties.id] = layer;
        },
      }).addTo(map);

      // --- FUNCI√ìN NUEVA: DIBUJAR RUTA COMPLETA POR CALLES ---

        function dibujarRutaCompleta() {
            // 1. Ordenar los puntos seg√∫n la propiedad "orden"
            const puntosOrdenados = misPuntos.features.sort((a, b) => {
                return a.properties.orden - b.properties.orden;
            });

            // 2. Crear coordenadas siguiendo las calles reales
            const coordenadasRutaCompleta = [];
            
            for (let i = 0; i < puntosOrdenados.length - 1; i++) {
                const puntoActual = puntosOrdenados[i];
                const puntoSiguiente = puntosOrdenados[i + 1];
                
                // Buscar ruta por calles entre estos puntos
                const claveRuta = `${puntoActual.properties.orden}_${puntoSiguiente.properties.orden}`;
                const rutaPorCalles = rutasCalles[claveRuta];
                
                if (rutaPorCalles && rutaPorCalles.length > 0) {
                    // Agregar coordenadas de la ruta por calles
                    for (const coord of rutaPorCalles) {
                        // Convertir [lon, lat] a [lat, lon] para Leaflet
                        coordenadasRutaCompleta.push([coord[1], coord[0]]);
                    }
                } else {
                    // Fallback: agregar solo los puntos inicio y fin
                    if (coordenadasRutaCompleta.length === 0) {
                        // Primer punto del recorrido
                        coordenadasRutaCompleta.push([
                            puntoActual.geometry.coordinates[1], 
                            puntoActual.geometry.coordinates[0]
                        ]);
                    }
                    // Punto siguiente
                    coordenadasRutaCompleta.push([
                        puntoSiguiente.geometry.coordinates[1], 
                        puntoSiguiente.geometry.coordinates[0]
                    ]);
                }
            }

            // 3. Dibujar la l√≠nea roja siguiendo calles reales
            if (coordenadasRutaCompleta.length > 1) {
                L.polyline(coordenadasRutaCompleta, {
                    color: '#e74c3c',       // Rojo elegante
                    weight: 3,              // Grosor medio
                    opacity: 0.7,           // Semi-transparente
                    dashArray: '8, 12'      // L√≠nea punteada distintiva
                }).addTo(map);
                
                console.log("üî¥ Ruta completa dibujada siguiendo calles reales");
            }
        }

        // ¬°Y llamamos a la funci√≥n para que se ejecute!
        dibujarRutaCompleta();

        // --- FUNCI√ìN NUEVA: SINTETIZADOR DE VOZ AVANZADO ---
        
        let vocesDisponibles = [];
        let vozMasculina = null;
        let vozFemenina = null;
        
        // Cargar voces disponibles
        function cargarVoces() {
            vocesDisponibles = speechSynthesis.getVoices();
            console.log("üé≠ Voces disponibles:", vocesDisponibles.length);
            
            // Buscar voces en espa√±ol
            const vocesEspanol = vocesDisponibles.filter(voz => 
                voz.lang.startsWith('es') || voz.name.toLowerCase().includes('spanish')
            );
            
            // Intentar encontrar voces por g√©nero
            vozFemenina = vocesEspanol.find(voz => 
                voz.name.toLowerCase().includes('female') ||
                voz.name.toLowerCase().includes('mujer') ||
                voz.name.toLowerCase().includes('woman') ||
                voz.name.toLowerCase().includes('maria') ||
                voz.name.toLowerCase().includes('carmen') ||
                voz.name.toLowerCase().includes('lucia') ||
                voz.name.toLowerCase().includes('microsoft zira') ||
                voz.name.toLowerCase().includes('google female')
            );
            
            vozMasculina = vocesEspanol.find(voz => 
                voz.name.toLowerCase().includes('male') ||
                voz.name.toLowerCase().includes('hombre') ||
                voz.name.toLowerCase().includes('man') ||
                voz.name.toLowerCase().includes('carlos') ||
                voz.name.toLowerCase().includes('diego') ||
                voz.name.toLowerCase().includes('microsoft pablo') ||
                voz.name.toLowerCase().includes('google male')
            ) || vocesEspanol[0]; // Fallback a la primera voz en espa√±ol
            
            // Si no encontramos voz femenina, usar cualquier voz diferente a la masculina
            if (!vozFemenina && vocesEspanol.length > 1) {
                vozFemenina = vocesEspanol.find(voz => voz !== vozMasculina) || vocesEspanol[0];
            }
            
            // Fallback: usar la primera voz disponible
            if (!vozMasculina) vozMasculina = vocesDisponibles[0];
            if (!vozFemenina) vozFemenina = vocesDisponibles[1] || vocesDisponibles[0];
            
            console.log("üë® Voz masculina (descripciones):", vozMasculina?.name || "No encontrada");
            console.log("üë© Voz femenina (navegaci√≥n):", vozFemenina?.name || "No encontrada");
        }
        
        // Funci√≥n de s√≠ntesis de voz mejorada
        function hablarTexto(texto, usarVozFemenina = false) {
            console.log(`üó£Ô∏è Hablando (${usarVozFemenina ? 'Voz femenina' : 'Voz masculina'}): ${texto}`);
            
            if (!('speechSynthesis' in window)) {
                console.log("‚ùå S√≠ntesis de voz no disponible");
                return;
            }
            
            try {
                // Detener cualquier voz que est√© sonando antes
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(texto);
                
                // Seleccionar voz seg√∫n el tipo de mensaje
                const vozSeleccionada = usarVozFemenina ? vozFemenina : vozMasculina;
                if (vozSeleccionada) {
                    utterance.voice = vozSeleccionada;
                    utterance.lang = vozSeleccionada.lang;
                } else {
                    utterance.lang = 'es-ES';
                }
                
                // Configurar par√°metros seg√∫n el tipo de voz
                if (usarVozFemenina) {
                    // Voz femenina para navegaci√≥n: m√°s clara y directiva
                    utterance.rate = 1.0;
                    utterance.pitch = 1.1;
                    utterance.volume = 0.9;
                } else {
                    // Voz masculina para descripciones: m√°s pausada y descriptiva
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.8;
                }
                
                utterance.onerror = (event) => {
                    console.error("Error en s√≠ntesis de voz:", event.error);
                };
                
                speechSynthesis.speak(utterance);
                
            } catch (e) {
                console.error("Error al sintetizar la voz: ", e);
            }
        }
        
        // Funci√≥n espec√≠fica para navegaci√≥n (usa voz femenina)
        function anunciarNavegacion(texto) {
            hablarTexto(texto, true); // true = usar voz femenina
        }
        
        // Cargar voces cuando est√©n disponibles
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = cargarVoces;
        }
        setTimeout(cargarVoces, 100); // Fallback por si no se dispara el evento

      // --- FASE 3: GEOLOCALIZACI√ìN EN TIEMPO REAL ---

      let marcadorUsuario = null; // Variable para guardar nuestro marcador
      let posicionActualUsuario = null; // <-- ¬°NUEVA L√çNEA!

      // 1. Opciones para la geolocalizaci√≥n
      const opcionesGeo = {
        enableHighAccuracy: true, // Pedir la m√°xima precisi√≥n posible
        timeout: 10000, // Tiempo m√°ximo de espera (10 seg)
        maximumAge: 0, // No usar una ubicaci√≥n "cacheada"
      };

      // 2. Comprobar si el navegador soporta Geolocation
      if ("geolocation" in navigator) {
        console.log("Geolocalizaci√≥n soportada. Iniciando...");

        // 3. Iniciar el "seguimiento" de la posici√≥n
        // 'watchPosition' se ejecuta CADA VEZ que el usuario se mueve
        navigator.geolocation.watchPosition(
          onUbicacionCorrecta,
          onUbicacionError,
          opcionesGeo
        ); 
      } else {
        alert(
          "Tu navegador no soporta Geolocalizaci√≥n. Esta aplicaci√≥n no funcionar√°."
        );
      }

      // 4. Funci√≥n que se ejecuta cuando OBTENEMOS la ubicaci√≥n
      function onUbicacionCorrecta(e) {
        const lat = e.coords.latitude;
        const lon = e.coords.longitude;

        posicionActualUsuario = L.latLng(lat, lon); // <-- ¬°NUEVA L√çNEA!

        const precision = e.coords.accuracy;

        console.log(
          `Nueva ubicaci√≥n: ${lat}, ${lon} (Precisi√≥n: ${precision}m)`
        );

        // Centrar el mapa en el usuario la primera vez
        if (marcadorUsuario == null) {
          map.setView([lat, lon], 17); // Nivel de zoom m√°s cercano
        }

        // Crear o actualizar el marcador del usuario
        if (marcadorUsuario) {
          // Si ya existe, solo movemos el marcador
          marcadorUsuario.setLatLng(posicionActualUsuario); // <-- ¬°L√çNEA MODIFICADA!
        } else {
          // Si no existe, lo creamos
          // Usamos un 'CircleMarker' para que se vea como un punto azul
          marcadorUsuario = L.circleMarker([lat, lon], {
            color: "#007bff", // Color del borde
            fillColor: "#007bff", // Color de relleno
            fillOpacity: 0.5,
            radius: 8,
          }).addTo(map);
        }
        // ... (aqu√≠ est√° tu c√≥digo para actualizar el 'marcadorUsuario')

        // Actualizar ruta visual si hay un punto siguiente destacado
        if (puntoSiguienteActual) {
          dibujarRutaHaciaSiguiente(puntoSiguienteActual);
        }

        // --- ¬°L√çNEA NUEVA! ---
        // Ahora, revisamos la proximidad con esta nueva ubicaci√≥n
        revisarProximidad(lat, lon);
      } // <-- Esta es la llave de cierre de onUbicacionCorrecta

      // 5. Funci√≥n que se ejecuta si hay un ERROR
      function onUbicacionError(error) {
        console.error("Error al obtener la ubicaci√≥n: " + error.message);
        // Errores comunes:
        // error.PERMISSION_DENIED - El usuario bloque√≥ el permiso
        // error.POSITION_UNAVAILABLE - GPS/Red no disponible
        // error.TIMEOUT - Se agot√≥ el tiempo de espera
        if (error.code == error.PERMISSION_DENIED) {
          alert(
            "Permiso de ubicaci√≥n denegado. Recarga la p√°gina y acepta para continuar."
          );
        }
      }

      // --- MODO TESTING CON TECLAS (PARA PC) ---
      
      // Variables para el modo testing
      let modoTesting = false;
      let posicionTestLat = -34.757; // Posici√≥n inicial en La Floresta
      let posicionTestLon = -55.665;
      
      // Aproximadamente 5 metros en coordenadas (esto puede variar seg√∫n la latitud)
      // En Uruguay, 1 grado de latitud ‚âà 111 km, 1 grado de longitud ‚âà 78 km
      const incremento = 0.00004; // Aproximadamente 5 metros
      
      // Funci√≥n para activar el modo testing
      function activarModoTesting() {
        if (!modoTesting) {
          modoTesting = true;
          console.log("üéÆ MODO TESTING ACTIVADO - Usa las flechas para moverte");
          
          // Mostrar estado en el panel
          document.getElementById('testing-status').style.display = 'block';
          
          // Posicionar en el centro de La Floresta
          posicionActualUsuario = L.latLng(posicionTestLat, posicionTestLon);
          
          // Crear o mover el marcador del usuario
          if (marcadorUsuario) {
            marcadorUsuario.setLatLng(posicionActualUsuario);
          } else {
            marcadorUsuario = L.circleMarker([posicionTestLat, posicionTestLon], {
              color: "#007bff",
              fillColor: "#007bff", 
              fillOpacity: 0.5,
              radius: 8,
            }).addTo(map);
          }
          
          // Centrar el mapa
          map.setView([posicionTestLat, posicionTestLon], 17);
          
          // Revisar proximidad inicial
          revisarProximidad(posicionTestLat, posicionTestLon);
        }
      }
      
      // Funci√≥n para mover la posici√≥n simulada
      function moverPosicionTest(direccion) {
        if (!modoTesting) return;
        
        switch(direccion) {
          case 'arriba':
            posicionTestLat += incremento;
            break;
          case 'abajo':
            posicionTestLat -= incremento;
            break;
          case 'izquierda':
            posicionTestLon -= incremento;
            break;
          case 'derecha':
            posicionTestLon += incremento;
            break;
        }
        
        // Actualizar posici√≥n actual
        posicionActualUsuario = L.latLng(posicionTestLat, posicionTestLon);
        
        // Mover el marcador
        if (marcadorUsuario) {
          marcadorUsuario.setLatLng(posicionActualUsuario);
        }
        
        // Centrar mapa en la nueva posici√≥n
        map.setView([posicionTestLat, posicionTestLon], 17);
        
        // Actualizar ruta visual si hay un punto siguiente destacado
        if (puntoSiguienteActual) {
          dibujarRutaHaciaSiguiente(puntoSiguienteActual);
        }
        
        // Revisar proximidad
        revisarProximidad(posicionTestLat, posicionTestLon);
        
        console.log(`üìç Nueva posici√≥n: ${posicionTestLat.toFixed(6)}, ${posicionTestLon.toFixed(6)}`);
      }
      
      // Escuchar eventos del teclado
      document.addEventListener('keydown', function(event) {
        // Activar modo testing con la tecla 'T'
        if (event.key.toLowerCase() === 't') {
          activarModoTesting();
          return;
        }
        
        // Solo funcionar si el modo testing est√° activo
        if (!modoTesting) return;
        
        // Prevenir el comportamiento predeterminado de las flechas
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
          event.preventDefault();
        }
        
        // Manejar las teclas de flecha
        switch(event.key) {
          case 'ArrowUp':
            moverPosicionTest('arriba');
            break;
          case 'ArrowDown':
            moverPosicionTest('abajo');
            break;
          case 'ArrowLeft':
            moverPosicionTest('izquierda');
            break;
          case 'ArrowRight':
            moverPosicionTest('derecha');
            break;
        }
      });
      
      // Mensaje inicial en consola
      console.log("üí° Para testing en PC: Presiona 'T' para activar modo testing, luego usa las flechas ‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è");

      // --- FASE 4: L√ìGICA DE PROXIMIDAD ---

      // ¬øA qu√© distancia (en metros) queremos activar el punto?
      // Para probar en PC, pon un valor alto (ej: 10000).
      // Para la vida real, un valor bueno es entre 20 y 30 metros.
      const radioActivacion = 30; // Radio para activar puntos
      const radioPopupCerrar = 60; // Radio para auto-cerrar popups (m√°s grande)

      // Funci√≥n que revisa si estamos cerca de alg√∫n punto
      function revisarProximidad(lat, lon) {
        const miPosicion = L.latLng(lat, lon);

        // 1. Recorremos TODOS nuestros puntos de inter√©s
        for (const feature of misPuntos.features) {
          const coordsPunto = feature.geometry.coordinates;
          const posPunto = L.latLng(coordsPunto[1], coordsPunto[0]); // Ojo: Lat, Lon
          const distancia = map.distance(miPosicion, posPunto);
          const marcador = marcadoresLeaflet[feature.properties.id];

          // 2. Comprobar activaci√≥n de puntos no visitados
          if (!feature.properties.visitado) {
            // 3. ¬°COMPROBAR LA PROXIMIDAD PARA ACTIVACI√ìN!
            if (distancia < radioActivacion) {
              console.log(`üéØ ¬°CERCA DE ${feature.properties.nombre}!`);
              activarPunto(feature);
            }
          }

          // 4. ¬°NUEVA FUNCIONALIDAD! Auto-cerrar popups cuando te alejas
          if (marcador && marcador.isPopupOpen() && distancia > radioPopupCerrar) {
            marcador.closePopup();
            console.log(`‚ùå Popup cerrado autom√°ticamente: ${feature.properties.nombre} (${Math.round(distancia)}m)`);
          }
        }
      }

   // --- FASE 4: L√ìGICA DE PROXIMIDAD (MODIFICADA) ---
        // ... (Aqu√≠ est√° tu variable 'radioActivacion') ...
        // ... (Aqu√≠ est√° tu funci√≥n 'revisarProximidad') ...

        // ¬°FUNCI√ìN 'activarPunto' MEJORADA CON AUDIO FALLBACK!
        function activarPunto(feature) {
            
            // 1. Marcar como visitado
            feature.properties.visitado = true;

            const id = feature.properties.id;
            const nombre = feature.properties.nombre;
            const descripcion = feature.properties.descripcion;
            const audioFile = feature.properties.audio;

            // 2. Abrir el Popup
            const marcador = marcadoresLeaflet[id];
            if (marcador) {
                marcador.openPopup();
            }

            // 3. Reproducir el Audio (con fallback a s√≠ntesis de voz)
            console.log(`üéØ PUNTO ACTIVADO: ${nombre}`);
            console.log(`üìç Intentando reproducir: ${audioFile}`);
            
            reproducirAudioConFallback(audioFile, nombre, descripcion, feature.properties.orden);
        }

        // Nueva funci√≥n para manejar audio con fallback
        function reproducirAudioConFallback(audioFile, nombre, descripcion, orden) {
            try {
                let audio = new Audio(audioFile);
                
                // Configurar eventos de audio
                audio.oncanplaythrough = () => {
                    console.log("‚úÖ Audio MP3 cargado correctamente");
                    mostrarNotificacion(`üéµ Reproduciendo: ${nombre}`, 'success');
                };
                
                audio.onerror = () => {
                    console.log("‚ùå Error de audio MP3, usando s√≠ntesis de voz");
                    usarSintesisDeVoz(nombre, descripcion, orden);
                };
                
                audio.onended = () => {
                    console.log("üèÅ Audio MP3 terminado");
                    anunciarSiguientePunto(orden);
                };
                
                // Intentar reproducir
                audio.play().catch((error) => {
                    console.log("‚ùå No se pudo reproducir audio MP3:", error.message);
                    usarSintesisDeVoz(nombre, descripcion, orden);
                });
                
            } catch (e) {
                console.log("‚ùå Error al crear audio MP3:", e.message);
                usarSintesisDeVoz(nombre, descripcion, orden);
            }
        }

        // Funci√≥n para usar s√≠ntesis de voz como respaldo
        function usarSintesisDeVoz(nombre, descripcion, orden) {
            mostrarNotificacion(`üó£Ô∏è Usando voz sint√©tica: ${nombre}`, 'info');
            
            if ('speechSynthesis' in window) {
                const texto = `Has llegado a ${nombre}. ${descripcion}`;
                
                // Usar voz masculina para las descripciones
                hablarTexto(texto, false); // false = voz masculina
                
                // Configurar callback para cuando termine la descripci√≥n
                setTimeout(() => {
                    console.log("üèÅ S√≠ntesis de voz terminada");
                    anunciarSiguientePunto(orden);
                }, texto.length * 80); // Estimar duraci√≥n basada en longitud del texto
                
            } else {
                console.log("‚ùå S√≠ntesis de voz no disponible");
                mostrarNotificacion(`üìù Punto visitado: ${nombre}`, 'info');
                setTimeout(() => anunciarSiguientePunto(orden), 2000);
            }
        }

        // Funci√≥n para mostrar notificaciones visuales
        function mostrarNotificacion(mensaje, tipo = 'info') {
            const notificacion = document.createElement('div');
            notificacion.className = `notificacion ${tipo}`;
            notificacion.textContent = mensaje;
            
            // Estilos inline para la notificaci√≥n
            notificacion.style.cssText = `
                position: fixed;
                top: 80px;
                right: 10px;
                padding: 12px 16px;
                border-radius: 6px;
                color: white;
                font-family: Arial, sans-serif;
                font-size: 14px;
                z-index: 1001;
                max-width: 300px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                transition: opacity 0.3s;
                background: ${tipo === 'success' ? '#4CAF50' : tipo === 'warning' ? '#FF9800' : '#2196F3'};
            `;
            
            document.body.appendChild(notificacion);
            
            // Remover despu√©s de 4 segundos
            setTimeout(() => {
                notificacion.style.opacity = '0';
                setTimeout(() => {
                    if (notificacion.parentNode) {
                        notificacion.parentNode.removeChild(notificacion);
                    }
                }, 300);
            }, 4000);
        }

        // === FUNCIONES DE NAVEGACI√ìN VISUAL ===
        
        // Funci√≥n para destacar visualmente el siguiente punto
        function destacarSiguientePunto(punto) {
            // Limpiar destacado anterior
            limpiarDestacadoAnterior();
            
            if (punto) {
                const marcador = marcadoresLeaflet[punto.properties.id];
                if (marcador) {
                    // Obtener el elemento DOM del icono
                    const iconElement = marcador._icon;
                    if (iconElement) {
                        const poiIcon = iconElement.querySelector('.poi-icon');
                        if (poiIcon) {
                            // Agregar clase de destacado
                            poiIcon.classList.add('icon-siguiente');
                            puntoSiguienteActual = punto;
                            console.log(`üéØ Destacando siguiente punto: ${punto.properties.nombre}`);
                        }
                    }
                }
            }
        }
        
        // Funci√≥n para limpiar el destacado anterior
        function limpiarDestacadoAnterior() {
            if (puntoSiguienteActual) {
                const marcadorAnterior = marcadoresLeaflet[puntoSiguienteActual.properties.id];
                if (marcadorAnterior && marcadorAnterior._icon) {
                    const poiIcon = marcadorAnterior._icon.querySelector('.poi-icon');
                    if (poiIcon) {
                        poiIcon.classList.remove('icon-siguiente');
                    }
                }
                puntoSiguienteActual = null;
            }
        }
        
        // Funci√≥n para dibujar ruta azul hasta el siguiente punto (SIGUIENDO CALLES)
        function dibujarRutaHaciaSiguiente(puntoDestino) {
            // Limpiar ruta anterior
            if (rutaActual) {
                map.removeLayer(rutaActual);
                rutaActual = null;
            }
            
            if (puntoDestino && posicionActualUsuario) {
                // Buscar ruta predefinida por calles
                const rutaPorCalles = obtenerRutaPorCalles(puntoDestino);
                
                if (rutaPorCalles && rutaPorCalles.length > 1) {
                    // Usar ruta predefinida que sigue las calles
                    console.log(`üõ£Ô∏è Usando ruta por calles hacia: ${puntoDestino.properties.nombre}`);
                    
                    // Convertir coordenadas [lon, lat] a [lat, lon] para Leaflet
                    const coordenadas = rutaPorCalles.map(coord => [coord[1], coord[0]]);
                    
                    // Agregar posici√≥n actual al inicio si no est√° incluida
                    const primeraCoord = coordenadas[0];
                    const distanciaPrimerPunto = map.distance(posicionActualUsuario, L.latLng(primeraCoord));
                    
                    if (distanciaPrimerPunto > 20) { // Si est√°s lejos del primer punto de la ruta
                        coordenadas.unshift([posicionActualUsuario.lat, posicionActualUsuario.lng]);
                    }
                    
                    rutaActual = L.polyline(coordenadas, {
                        color: '#2196F3',        // Azul material design
                        weight: 6,               // M√ÅS ANCHO para mejor visibilidad
                        opacity: 0.9,            // M√°s opaco para destacar
                        dashArray: '10, 5',      // L√≠nea punteada
                        dashOffset: '0'
                    }).addTo(map);
                    
                } else {
                    // Fallback: l√≠nea recta si no hay ruta predefinida
                    console.log(`‚û°Ô∏è Usando l√≠nea recta hacia: ${puntoDestino.properties.nombre} (no hay ruta por calles)`);
                    
                    const destino = L.latLng(
                        puntoDestino.geometry.coordinates[1], // lat
                        puntoDestino.geometry.coordinates[0]  // lon
                    );
                    
                    rutaActual = L.polyline([posicionActualUsuario, destino], {
                        color: '#FF9800',        // Naranja para indicar que es l√≠nea recta
                        weight: 6,               // M√ÅS ANCHO, igual que la ruta por calles
                        opacity: 0.7,            // Ligeramente menos opaco
                        dashArray: '15, 10',     // M√°s espaciado para diferenciarlo
                        dashOffset: '0'
                    }).addTo(map);
                }
                
                // Animar la l√≠nea punteada
                let offset = 0;
                function animarLinea() {
                    if (rutaActual && map.hasLayer(rutaActual)) {
                        offset += 2;
                        rutaActual.setStyle({ dashOffset: -offset });
                        setTimeout(animarLinea, 100);
                    }
                }
                animarLinea();
            }
        }
        
        // Funci√≥n para obtener ruta predefinida por calles
        function obtenerRutaPorCalles(puntoDestino) {
            // Buscar el punto actual visitado para determinar el origen
            const puntoActual = encontrarPuntoAnterior(puntoDestino.properties.orden);
            
            if (puntoActual) {
                const claveRuta = `${puntoActual.properties.orden}_${puntoDestino.properties.orden}`;
                console.log(`ÔøΩ Buscando ruta: ${claveRuta}`);
                return rutasCalles[claveRuta] || null;
            }
            
            return null;
        }
        
        // Funci√≥n para encontrar el punto anterior visitado
        function encontrarPuntoAnterior(ordenDestino) {
            // Buscar el √∫ltimo punto visitado antes del destino
            let puntoAnterior = null;
            let mayorOrden = 0;
            
            for (const feature of misPuntos.features) {
                if (feature.properties.visitado && 
                    feature.properties.orden < ordenDestino && 
                    feature.properties.orden > mayorOrden) {
                    mayorOrden = feature.properties.orden;
                    puntoAnterior = feature;
                }
            }
            
            return puntoAnterior;
        }
        
        // Funci√≥n integrada para gesti√≥n visual completa
        function actualizarNavegacionVisual(siguientePunto) {
            destacarSiguientePunto(siguientePunto);
            dibujarRutaHaciaSiguiente(siguientePunto);
        }

        // ¬°FUNCI√ìN 'anunciarSiguientePunto' MEJORADA CON VISUALES!
        function anunciarSiguientePunto(ordenActual) {
            const siguientePunto = encontrarSiguientePunto(ordenActual);
            
            if (siguientePunto && posicionActualUsuario) {
                const nombreSiguiente = siguientePunto.properties.nombre;

                // Calcular la distancia desde el usuario al siguiente punto
                const posSiguiente = L.latLng(
                    siguientePunto.geometry.coordinates[1], // lat
                    siguientePunto.geometry.coordinates[0]  // lon
                );
                
                const distancia = map.distance(posicionActualUsuario, posSiguiente);
                const distanciaRedondeada = Math.round(distancia); // en metros

                // === MEJORAS VISUALES ===
                // Destacar el siguiente punto y dibujar ruta azul
                actualizarNavegacionVisual(siguientePunto);

                // Crear el texto del anuncio
                const textoAnuncio = `Siguiente parada: ${nombreSiguiente}. Se encuentra a ${distanciaRedondeada} metros.`;

                // Usar voz femenina para navegaci√≥n
                mostrarNotificacion(`üë©‚Äçüó£Ô∏è Navegaci√≥n: ${nombreSiguiente}`, 'info');
                anunciarNavegacion(textoAnuncio); // Usa voz femenina
                
            } else if (!siguientePunto) {
                // Es el √∫ltimo punto - limpiar todos los visuales
                limpiarDestacadoAnterior();
                if (rutaActual) {
                    map.removeLayer(rutaActual);
                    rutaActual = null;
                }
                
                // Voz femenina para finalizaci√≥n
                anunciarNavegacion("Has completado el recorrido. ¬°Gracias por visitarnos!");
                mostrarNotificacion(`üéâ ¬°Recorrido completado!`, 'success');
            }
        }

        // (Fase 5) Funci√≥n de ayuda (ya la ten√≠as)
        function encontrarSiguientePunto(ordenActual) {
            const siguienteOrden = ordenActual + 1;
            return misPuntos.features.find(f => f.properties.orden === siguienteOrden);
        }
      
    </script>
  </body>
</html>
